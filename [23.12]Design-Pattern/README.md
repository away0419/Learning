> ## 디자인 패턴

- 공통적으로 발생하는 문제의 해결 방법을 패턴화 한 것.
- 템플릿이라 생각할 수 있으며 재사용 가능함.
- 소프트웨어 아키텍처와 다르게 패턴은 코드 수준에서 담당하는 것. 즉, 더 작은 범주의 설계를 담당함.
- 디자인 패턴은 독립적으로 서술 된 패턴이 아닐 수 있음.
  - 싱글톤 패턴이 다른 패턴에서 사용될 수 있는 것처럼 패턴 안에 다른 패턴이 포함되어 있을 수 있음.
- 비슷한 구조를 가진 패턴이 여러개 일 수 있음. 패턴이란 결국 코드의 구조가 아닌 의도에 따라 다르다고 생각하면 됨.
- 객체와 클래스의 차이를 인지해야 이해하기 편함.
  - 객체가 달라도 클래스는 동일할 수 있다.

<br/>
<br/>

> ## 디자인 패턴 종류

<details>
  <summary>생성 패턴</summary>

- 객체 인스턴스를 생성하는 패턴.
- 클라이언트와 생성해야 하는 객체 인스턴스 사이의 연결을 끊어 주는 역할.

  <details>
    <summary>싱글톤 (Singleton)</summary>

  - 객체 인스턴스를 하나만 만들고 이 인스턴스에 대한 전역 접근을 제공하는 패턴.
  - 장점
    - 메모리 낭비를 방지할 수 있음.
    - 생성된 인스턴스를 활용하므로 속도 측면에서 이점이 있음.
    - 다른 클래스 간 데이터 공유가 쉬움.
  - 단점
    - 동시성 이슈 발생할 수 있음.
    - 코드량 증가.
    - 격리된 테스트 수행에 어려움이 있음.
    - 자식 클래스를 만들 수 없음.
    - 내부 상태 변경이 어려움.
    - 개방-폐쇄 원칙에 어긋남.
  - 주로 사용되는 상황.

    - 커넥션풀
    - 스레드풀
    - 캐시
    - 로그 기록 객체

  </details>

  <details>
    <summary>팩토리 메소드 (Factory Method)</summary>

  ![Alt text](image/factoryMethod-1.png)

  - 객체 생성을 생성자로 하는 것이 아닌, 객체 생성 메소드를 가진 [인터페이스 또는 추상 클래스]를 만들고(캡슐화) 이를 상속 받은 서브 클래스를 만들거나 다이렉트로 객체 생성 메소드만 가진 클래스를 만들어 사용하는 패턴. (상황에 맞춰 중 선택)
  - 장점
    - 생성자와 구현 객체의 강한 결합을 피할 수 있음.
    - 리턴 타입을 해당 클래스가 아닌 부모 타입으로 할 수 있음.
    - 기존 객체를 재구성하는 대신 확장하여 리소스를 절약할 수 있음.
    - 단일 책임 원칙 준수할 수 있음. (객체 생성이라는 하나의 목적을 가진 클래스를 한 곳에 모아 관리 가능)
    - 개방-폐쇄 원칙 준수할 수 있음. (기존 객체 확장)
  - 단점

    - [인터페이스, 추상클래스, 서브클래스] 구현으로 인한 클래스 증가.
      - 생성자로 객체 생성하면 만들 필요가 없기 때문.
    - 코드 복잡성 증가.
      - 어떤 클래스와 이어져 있는지 확인 해야 함.

  </details>

  <details>
    <summary>추상 팩토리 (Abstract Factory)</summary>

  ![Alt text](image/abstractFactory-1.png)

  - 연관되는 객체를 집합으로 묶어 추상화 한 뒤, 해당 집합의 객체들을 한번에 생성할 수 있게 구현하여 연관 객체들을 생성하는 패턴.
  - 객체 생성을 생성자로 바로 하는 것이 아니고 캡슐화 한다는 점은 팩토리 메소드와 같으나 상위 개념은 아님.
    - 이해가 안된다면 팩토리 메소드는 단일, 추상 팩토리는 다수의 객체를 생성한다고 생각하면 됨.
    - 팩토리 메소드 -> 키보드, 마우스, 모니터 각각 단일 생성
    - 추상 팩토리 -> 삼성세트(키보드, 마우스, 모니터), LG세트(키보드, 마우스, 모니터)
  - 장점
    - 객체 생성 코드를 분리하여 클라이언트 코드와 결합도를 낮출 수 있음.
    - 단일 책임 원칙 준수.
    - 개방/폐쇄 원칙 준수.
  - 단점

    - 객체가 늘어날때 마다 클래스가 증가.
    - 코드의 복잡성 증가.
    - 객체 집한에 새로운 객체를 추가할 경우 수정해야 되는 부분이 많음.

  </details>

  <details>
    <summary>정적 팩토리 메소드 패턴 (Static Factory Method)</summary>

  - static Method를 이용하여 객체를 생성하는 패턴.
  - 장점
    - 생성 목적에 대한 이름 표현 가능. (팩토리 동일)
    - 인스턴스 통제 가능. (싱글톤으로 만들기)
    - 하위 자료형 리턴 가능. (팩토리 동일)
    - 인자에 따라 다른 값 변경 가능. (팩토리 동일)
    - 객체 생성 캡슐화 가능. (팩토리 동일)
    - 불필요한 인터페이스, 서브 클래스 줄일 수 있음.
    - 실제 객체 없이 메소드 이용 가능.
  - 단점
    - 부모가 되기 위해선 public 혹은 protected 생성자가 필요하므로 정적 팩토리 메소드만 제공할 경우 상속 불가.
  - 정적 팩토리 메소드 네이밍 규칙

    - from : 자신의 타입 객체를 생성. (매개변수 0개 이상, 타입 상관 x, 주로 다른 타입)
    - of : 적절한 타입 객체 생성. (매겨변수 0개 이상, 타입 상관 x)
    - valueOf : from과 of의 자세한 버전. (매개변수 1개, 해당 매개변수의 타입을 현재 클래스의 타입으로 바꿀 때 주로 사용)
    - getInstance | instance : 인스턴스를 생성 혹은 반환. (매개변수를 받을 경우 명시한 인스턴스를 반환. 그러나 같은 인스턴스임을 보장하지는 않음)
    - newInstance | create : 항상 새로운 인스턴스 생성 (항상 새로운 인스턴스를 생성하여 다른 인스턴스임을 보장)
    - get[orderType] : 다른 타입의 인스턴스 생성. (getInstance와 동일. 단, 인스턴스의 타입은 [orderType])
    - new[orderType] : 항상 다른 타입의 새로운 인스턴스 생성. (getInstance와 동일. 단, 인스턴스의 타입은 [orderType])

  </details>

  <details>
    <summary>이넘 팩토리 메소드 패턴 (Enum Factory Method)</summary>

  - Enum을 이용한 객체 생성 패턴.
  - 장점
    - 정적 팩토리 메소드와 동일.
  - 단점
    - 정적 팩토리 메소드와 동일.
  - static과 차이가 별로 나지 않음.

  </details>

  <details>
    <summary>다이나믹 팩토리 패턴 (Dynamic Factory)</summary>

  - 자바의 Class 클래스를 이용한 [Reflection API](https://github.com/away0419/Study-2023/tree/main/%5B23.01%5DLanguage/Java/ReflectionAPI) 기법을 이용한 패턴.
  - 장점
    - 이넘 팩토리 메소드의 문제점인 객체 상속을 해결.
  - 단점

    - 예외 처리 필수.

  </details>

  <details>
    <summary>빌더 패턴 (Builder)</summary>

  - 복잡한 객체 생성 방법을 단계별로 나누어 생성하는 패턴.
  - 기존의 자바 빈 패턴의 경우 일관성과 불변성에 문제가 발생함.
    - 객체 생성 후 setter를 깜빡할 경우 일관성 문제 발생.
    - 객체 생성 후 setter로 값을 변경할 경우 불변성 문제 발생.
  - 장점
    - 매개변수가 많을 때 일관된 프로세스로 표현하여 가독성을 증가시킴.
    - 필수 멤버와 선택 멤버 분리 가능.
    - 단일 책임 원칙, 복잡한 생성 코드를 고립시킬 수 있음.
    - 객체 생성을 지연할 수 있음.
  - 단점

    - 빌더 클래스를 따로 만들어야 하므로 코드 복잡성 증가.
      - 이를 해결하려면 빌더 클래스를 해당 객체의 정적 이너 클래스로 만들면 됨.
    - 생성자 보다 성능이 떨어짐.
    - 필드 개수가 적다면 빌더 패턴은 과함.

  </details>

  <details>
    <summary>프로토타입 (Prototype)</summary>

  - 원본 객체를 새로운 객체에 복사하는 패턴.
  - 객체를 처음부터 생성하기엔 비용이 많이 들 경우, 이미 존재하는 객체를 복사할때 사용.
    - ex) 동일한 목록을 DB에서 가져오는 경우. (가져온 정보는 같으나 새로운 객체에 담고 있는 경우)
    - ex) 객체 생성에 수 많은 설정을 해줘야 하는 경우.
  - 장점
    - 복잡한 객체 생성 과정을 숨길 수 있음.
    - 비용을 줄일 수 있음. (객체생성보다 복사가 효율적일 수 있기 때문)
    - 구체 클래스 없이 객체를 복사할 수 있음.
  - 단점 - 순환 참조가 있는 객체들은 복제 과정 자체가 복잡할 수 있음.

  </details>

</details>

<br>

<details>
  <summary>구조 패턴</summary>

- 클래스와 객체를 더 큰 구조로 만들 수 있게 구성을 사용하는 패턴.

  <details>
    <summary>어댑터 (Adapter)</summary>

  - 호환되지 않는 인터페이스를 가진 객체들이 협업할 수 있도록 하는 패턴.
  - 어댑터 패턴 구조는 2가지가 있음.
    - 객체 어댑터 (합성, 추천)
      - 새로운 기능을 가진 인터페이스 생성.
      - 해당 인터페이스를 상속받으며 멤버 변수로 기본 서비스 객체를 가지는 새로운 클래스 생성.
      - 이를 통해 새로운 클래스는 기존 서비스 객체를 이용하여 기존 서비스 기능을(메소드) 사용할 수 있으며, 새로운 기능을 구현하여 사용할 수 있음.
      - 멤버 변수로 인해 공간 차지 비용이 발생함.
    - 클래스 어댑터 (상속)
      - 새로운 기능을 가진 인터페이스 생성.
      - 해당 인터페이스와 기존 서비스 객체를 동시에 상속 받는 새로운 클래스 생성.
      - 기존 서비스 객체의 기능을 오버라이딩 할 수 있으며, 새로운 기능을 구현하여 사용 가능.
      - 다중 상속이 문제가 될 수 있음.
  - 장점
    - 호환성 및 기능 확장 가능.
    - 단일 책임 원칙 준수.
    - 개방/폐쇄 원칙 준수.
  - 단점
    - 다수의 인터페이스와 클래스 도입으로 코드 복잡성 증가.

  </details>

  <details>
    <summary>브릿지 (Bridge)</summary>

  - 기능 혹은 부속 객체가 많은 큰 클래스를 추상으로 나누어 구현하는 패턴.
  - 즉, [기능, 특징]별 [인터페이스, 추상클래스]를 만들고 이를 상속 받거나, [인터페이스, 추상클래스]를 구현한 객체를 멤버 변수로 가지는 큰 객체를 만드는 것.
  - 하나의 클래스를 통해 여러 종류의 객체를 만들 수 있음.
    - ex) 파란색 버튼, 노란색 버튼, 빨간색 버튼
    - ex) 발사 버튼, 정지 버튼, 시작 버튼
  - 일반적으로 사전에 설계됨. 따라서 어댑터와 비슷한 구조이나, 개념이 다름.
  - 장점
    - 플랫폼 독립적인 클래스들 생성 가능.
    - 추상화를 통해 세부 정보 노출 방지.
    - 개방/폐쇄 원칙 준수.
    - 단일 책임 원칙 준수.
  - 단점
    - 큰 클래스일수록 코드 복잡도 상승.

  </details>

  <details>
    <summary>컴포지트 (Composite)</summary>

  - 객체들을 트리 구조로 구성한 후, 개별 객체처럼 작업할 수 있도록 하는 패턴.
    - ex) 상자 안에 상자, 마트료시카
  - 장점
    - 다형성과 재귀를 통해 보다 복잡한 트리 구조들을 관리할 수 있음.
    - 개방/폐쇄 원칙 준수.
  - 단점
    - 공통 인터페이스를 만들기 어려울 수 있음.

  </details>

  <details>
    <summary>데코레이터 (Decorator)</summary>

  - 래퍼 객체를 활용하여 기존 객체에 기능 혹은 특징을 추가하고 반환 하는 패턴.
    - 비슷한 패턴이 많은데 해당 패턴은 기존 객체를 받아 기능을 더해 반환하는 것이라 생각하면 편함.
  - 캐싱, 로깅, 검증 기능에 사용 가능.
  - 클래스의 수에는 차이가 없을 수 있으나 중복 코드를 줄일 수 있음.
    - ex) 피자 맛을 print할 때, 기본 피자면 -> 피자맛, 치즈 추가 시 -> 치즈 피자맛, 불고기 추가 시 -> 불고기 치즈 피자맛. 공통 되는 피자맛 print를 재사용 가능함.
  - 장점
    - 데코레이터를 이용해 기능을 조합할 수 있음. (유연성 증가)
    - 런타임에서 기능 변경 가능.
    - 단일 책임 원칙 준수.
    - 개방/폐쇄 원칙 준수.
    - 의존 역전 윈칙 준수.
  - 단점
    - 코드 복잡성 증가.
    - 추가된 데코레이션은 제거가 쉽지 않음.

  </details>

  <details>
    <summary>퍼사드 (Facade)</summary>

  - 하나의 행위를 위해 여러 클래스의 메소드를 사용해야 할 경우, 해당 행위를 메소드로 구현한 클래스를 따로 만드는 패턴.
    - 인터페이스를 제공함. (여기서 인터페이스는 타입이 아니고 사용자가 사용하는 인터페이스를 뜻함.)
    - ex) 사람이 피자를 토핑하고 가져와 TV를 보며 먹는 기능을 하나의 클래스 기능으로 구현하는 것. 사람 객체: 가져오기, 먹기, 보기. 피자: 토핑 추가. TV 객체: 켜기.
  - 적절히 기능 집약화만 해주면 되는 패턴.
  - 장점
    - 하위 시스템의 복잡성에서 코드를 분리하여, 외부에서 시스템 사용이 용이해짐.
    - 하위 시스템간의 의존 관계가 많을 경우 이를 감소시키고 의존성을 한 곳으로 모을 수 있음.
      - 퍼사드 객체 안에 기능이 모여 있기 때문에 내부 로직을 바꾸더라도 외부 로직에는 영향을 주지 않아 의존성을 감소 시킬 수 있음.
    - 복잡한 코드를 감출 수 있음.
  - 단점
    - 퍼사드 객체가 모든 클래스에 결합된 God 객체가 될 수 있음.
    - 퍼사드 클래스 자체가 의존성을 가지게 됨.
    - 추가 코드가 늘어나는 것이므로 유지보수 비용 커짐.

  </details>

  <details>
    <summary>플라이웨이트 (FlyWeight)</summary>

  - 재사용 가능한 객체 인스턴스를 공유하여 메모리 사용량을 최소화 하는 패턴.
  - 자주 변하는 속성과 그렇지 않은 속성을 분리하고 변하지 않는 속성을 캐시하여 재사용하는 방식.
  - 유사한 객체들 사이에 가능한 많은 데이터를 서로 공유하여 사용하는 경량 패턴.
  - 장점
    - 메모리를 줄일 수 있음.
    - 프로그램 속도 개선 가능.
  - 단점
    - 코드 복잡성 증가.

  </details>

  <details>
    <summary>프록시 (Proxy)</summary>

  - 원본 객체를 대신하여 처리할 수 있도록 로직의 흐름을 제어하는 행동 패턴이자 구조 패턴임.
  - 프록시 객체를 통해 실제 객체가 메모리에 존재하지 않아도 기본적인 정보를 참조하거나 설정할 수 있으며 꼭 필요하기 전까지 객체 생성을 미룰 수 있음.
    - 프록시 객체가 실제 객체가 가지는 메소드를 가지고 있음. 단, 기능이 구현된 것이 아님. 실제 객체를 생성하고 이름이 동일한 메소드를 다시 부르는 과정이 구현되어 있음.
    - 이를 통해, 메인에서 메소드를 부르기 전 까진 프록시 객체만 가지고 실제 객체가 있는 것처럼 동작할 수 있다는 뜻임.
  - 프록시 패턴 종류
    - 기본형 프록시
      - 어댑터 패턴이랑 흡사함.
    - 가상 프록시
      - 객체가 필요할 때까지 생성을 미루고, 그 전까지 생성되어 있는 것처럼 동작하도록 만들 때 사용.
      - 객체 생성에 많은 자원이 소모 되지만 사용 빈도가 낮을 때 쓰는 방식.
    - 보호 프록시
      - 주체 클래스에 대한 접근을 제어하기 위한 경우에 사용.
      - 접근 권한을 제한하거나 주체 클래스에 대한 접근을 허용하지 말지 결정.
  - 장점
    - 개방/폐쇄 원칙 준수.
    - 단일 책임 원칙 준수.
    - 사이즈가 큰 객체 로딩되기 전에도 프록시를 통해 일부 참조 가능.
  - 단점
    - 코드 복잡도 증가.
    - 객체 생성할 때 프록시 객체를 생성하게 되므로 빈번한 객체 생성의 경우 성능이 저하될 수 있음.
    - 프록시 내부에서 객체 생성을 위해 스레드가 생성, 동기화 기능이 구현되어야 하는 경우 성능이 저하될 수 있음.

  </details>

</details>

<br>

<details>
  <summary>행동 패턴</summary>

- 클래스와 객체들이 상호 작용하는 방법과 역할을 분담하는 방법을 다루는 패턴.

  <details>
    <summary>책임 연쇄 (Chain-Of-Responsibility)</summary>
    
  - 요청에 대한 처리를 하나가 아닌 여러 객체로 나누고, 이들을 사슬처럼 연결해 안에서 연쇄적으로 처리하는 패턴.
  - 처리 객체들을 핸들러라고하며, 각 핸들러는 요청을 처리할 수 있는지 확인 후, 처리 할 수 없다면 다음 핸들러에게 넘김.
  - 중첩 if-else 문을 해당 패턴으로 구성할 수 있음.
  - 장점
    - 클라이언트는 내부 구조를 알 필요가 없음.
    - 각각의 체인이 자신의 일만 처리하면 되기 때문에 새로운 요청에 대한 처리 객체 생성이 편리해짐.
    - 클라이언트 코드를 변경하지 않고도 수정할 수 있음.
    - 요청의 호출과 수신을 분리하여 결합도를 낮출 수 있음.
  - 단점
    - 실행 시 코드의 흐름이 많아져 디버깅 및 테스트가 쉽지 않음.
    - 무한 사이클이 발생할 수 있음.
    - 요청이 반드시 수행된다는 보장이 없음.
    - 처리 지연 문제가 발생할 수 있음.

  </details>

  <details>
    <summary>커맨드 (Command)</summary>

  - 객체의 메소드를 클래스로 만들어 캡슐화 하는 패턴.
  - 책임 연쇄와 코드 구조가 비슷함. 다른 점은 체인이 없이 바로 실행 한다는 것.
  - 장점
    - 단일 책임 원칙 준수.
    - 개방/폐쇄 원칙 준수.
    - 작업 지연 실행 가능
  - 단점
    - 코드 복잡성 증가.

  </details>

  <details>
    <summary>인터프리터</summary>

  - 언어나 문법을 해석하고 실행하는 패턴.
    - ex) 정규 표현식
  - 장점
    - 캐슐화를 통한 유지보수 상승
    - 쉬운 확장
    - 가독성 증가
  - 단점
    - 코드 복잡성 증가
    - 성능이 떨어질 수 있음.

  </details>

  <details>
    <summary>반복자</summary>

  - 일련의 데이터 잡합에 순차적인 접근을 지원하는 패턴.
  - Java에서 순차적으로 Collection에서 꺼내쓰는 Iterator 가 이에 해당함.
  - 장점
    - 일관된 순회 방법 제공.
    - 클라이언트는 내부 구조 및 순회 방식을 몰라도 됨.
    - 결합도를 낮출 수 있음.
    - 단일 책임 원칙 준수.
    - 개방/폐쇄 원칙 준수.
  - 단점
    - 클래스가 늘어나고 복잡도 증가.
    - 구현 방법에 따라 캡슐화를 위배할 수 있음.

  </details>

  <details>
    <summary>중재자</summary>

  - 객체 간의 복잡한 관계들을 캡슐화 하여 하나의 클래스에서 관리하는 패턴.
  - M:N 관계를 M:1 관계로 만들 수 있음. (1이 중재자)
  - 중재자는 모든 객체들의 통신을 담당함.
  - 장점
    - 단일 책임 원칙 준수
    - 개방/폐쇄 원칙 준수
    - 객체 간 결합도 감소
    - 재사용성 상승
  - 단점
    - 중개자가 모든 객체를 가지는 클래스가 될 수 있음.

  </details>

  <details>
    <summary>메멘토</summary>

  - 현재 객체의 데이터를 메멘토 객체에 저장하고 원하는 시점의 객체 데이터를 복원 할 수 있는 패턴.
  - 장점
    - 데이터를 다른 객체에 보관하여 안전함.
    - 데이터를 계속해서 캡슐화된 상태로 유지가능.
    - 복구 기능을 구현하기 쉬움.
  - 단점
    - 새로운 객체를 만드는 것이므로 메모리가 필요함.
    - 객체 생성과 찾는 과정에 시간이 발생.

  </details>

- 메멘토
- 옵저버
- 상태
- 전략
- 템플릿 메소드
- 비지터

</details>

<br/>
<br/>
